"use client";

import React, {
  createContext,
  useCallback,
  useContext,
  useMemo,
  useRef,
  useState,
  useEffect,
  Dispatch,
  SetStateAction,
} from "react";
import { showToast } from "@/helper/show-toast";
import { useTranslations } from "next-intl";
import {
  useContentAutoGenerateGetSettings,
  useContentAutoGenerateUpdatePreference,
  useContentAutoGenerateCreateSchedule,
  useContentAutoGenerateUpdateSchedule,
  useContentAutoGenerateDeleteSchedule,
  useContentAiModelGetAiModels,
} from "@/services/content/content.api";
import {
  AutoGenerateSettings,
  AutoGenerateSchedule,
  CreateAutoGenerateScheduleRequest,
  UpdateAutoGenerateScheduleRequest,
} from "@/models/api/content/auto-generate";
import { useParams } from "next/navigation";
import { FilterQuery, Pagination } from "@/models/api/base-response.type";
import {
  AdvancedGenerate,
  GenerateContentAdvanceBase,
  GenerateContentBase,
  ValidRatio,
} from "@/models/api/content/image.type";
import { ProductKnowledgeRes } from "@/models/api/knowledge/product.type";
import { AiModelRes } from "@/models/api/content/ai-model";
import {
  useProductKnowledgeGetAll,
  useProductKnowledgeGetStatus,
} from "@/services/knowledge.api";
import {
  useLibraryTemplateGetPublished,
  useLibraryTemplateGetSaved,
  useLibraryTemplateGetProductCategory,
  useLibraryTemplateSave,
  useLibraryTemplateDeleteSaved,
} from "@/services/library.api";

// Template interface
export interface Template {
  id: string;
  name: string;
  imageUrl: string;
  categories: string[];
  productCategories: string[];
  publisher: {
    id: string;
    name: string;
    image: string | null;
  } | null;
  createdAt: string;
  updatedAt: string;
  price: 0;
  type: "saved" | "published";
}

// Form interfaces
interface BasicForm extends GenerateContentBase {
  productName: string;
  productImage: string;
  customCategory: string;
  customDesignStyle: string;
  referenceImageName: string | null;
  referenceImagePublisher: string | null;
  caption: string;
  model: string;
  imageSize: string | null;
}

type Ctx = {
  // Auto Generate Settings
  enabled: boolean;
  schedules: AutoGenerateSettings;
  isValueChanged: boolean;
  loading: boolean;
  onUpsert: () => Promise<void>;
  confirmLeave: () => boolean;
  guardedNavigate: (href: string, navigate: (href: string) => void) => void;
  setGlobalEnabled: (next: boolean) => void;
  toggleDay: (day: number) => void;
  addSchedule: (day: number, schedule: CreateAutoGenerateScheduleRequest) => void;
  updateSchedule: (scheduleId: string, schedule: UpdateAutoGenerateScheduleRequest) => void;
  removeSchedule: (scheduleId: string) => void;
  deleteScheduleDirectly: (scheduleId: string) => Promise<void>;
  getSchedulesByDay: (day: number) => AutoGenerateSchedule[];

  // Form Management
  form: {
    basic: BasicForm;
    advance: GenerateContentAdvanceBase;
    setBasic: (item: BasicForm) => void;
    setAdvance: (item: GenerateContentAdvanceBase) => void;
    enabledAdvance: AdvancedGenerate;
    setEnabledAdvance: (item: AdvancedGenerate) => void;
    mask: string | null;
    setMask: Dispatch<SetStateAction<string | null>>;
  };

  // Template Management
  selectedTemplate: Template | null;
  setSelectedTemplate: (template: Template | null) => void;
  publishedTemplates: {
    contents: Template[];
    pagination: Pagination;
    filterQuery: Partial<FilterQuery>;
    setFilterQuery: (q: Partial<FilterQuery>) => void;
    isLoading: boolean;
  };
  savedTemplates: {
    contents: Template[];
    pagination: Pagination;
    filterQuery: Partial<FilterQuery>;
    setFilterQuery: (q: Partial<FilterQuery>) => void;
    isLoading: boolean;
  };

  // Product Knowledge
  productKnowledges: {
    contents: ProductKnowledgeRes[];
    pagination: Pagination;
    filterQuery: Partial<FilterQuery>;
    setFilterQuery: (q: Partial<FilterQuery>) => void;
  };

  // AI Models
  aiModels: {
    models: AiModelRes[];
    selectedModel: AiModelRes | null;
    validRatios: string[];
    isLoading: boolean;
  };

  // Loading state
  isLoading: boolean;
  setIsLoading: (item: boolean) => void;

  // Unsave modal
  unsaveModal: {
    isOpen: boolean;
    item: Template | null;
    isLoading: boolean;
  };
  setUnsaveModal: (modal: { isOpen: boolean; item: Template | null; isLoading: boolean }) => void;

  // Handlers
  onSaveUnsave: (item: Template) => void;
  onConfirmUnsave: () => void;
  onCloseUnsaveModal: () => void;
  onSelectProduct: (item: ProductKnowledgeRes | null) => void;
  onSelectReferenceImage: (
    imageUrl: string,
    imageName: string | null,
    template?: Template
  ) => void;
  onSelectAiModel: (model: AiModelRes) => void;
  onResetAdvance: () => void;
};

const AutoGenerateContext = createContext<Ctx | null>(null);

export function useAutoGenerate() {
  const ctx = useContext(AutoGenerateContext);
  if (!ctx)
    throw new Error(
      "useAutoGenerate must be used within AutoGenerateProvider"
    );
  return ctx;
}


function stableSig(obj: unknown) {
  return JSON.stringify(obj);
}

// Initial form values
const initialEnabledAdvance: AdvancedGenerate = {
  businessKnowledge: {
    name: false,
    category: false,
    description: false,
    location: false,
    uniqueSellingPoint: false,
    visionMission: false,
    website: false,
    logo: false,
    colorTone: false,
  },
  productKnowledge: {
    name: false,
    category: false,
    description: false,
    price: false,
  },
  roleKnowledge: {
    hashtags: false,
  },
};

const initialFormBasic: BasicForm = {
  category: "Default",
  designStyle: "Default",
  productKnowledgeId: "",
  prompt: "",
  ratio: "1:1",
  referenceImage: null,
  productName: "",
  productImage: "",
  customCategory: "",
  customDesignStyle: "",
  referenceImageName: null,
  referenceImagePublisher: null,
  caption: "",
  model: "",
  imageSize: null,
};

const initialFormAdvance: GenerateContentAdvanceBase = {
  businessKnowledge: {
    category: false,
    description: false,
    location: false,
    name: false,
    uniqueSellingPoint: false,
    visionMission: false,
    website: false,
    logo: true,
    colorTone: true,
  },
  productKnowledge: {
    category: false,
    description: false,
    name: true,
    price: false,
  },
  roleKnowledge: {
    hashtags: false,
  },
};

const initialPagination: Pagination = {
  limit: 10,
  page: 1,
  total: 0,
  totalPages: 0,
  hasNextPage: false,
  hasPrevPage: false,
};

export function AutoGenerateProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const { businessId } = useParams() as { businessId: string };
  const t = useTranslations();
  const mUpdatePreference = useContentAutoGenerateUpdatePreference();
  const mCreateSchedule = useContentAutoGenerateCreateSchedule();
  const mUpdateSchedule = useContentAutoGenerateUpdateSchedule();
  const mDeleteSchedule = useContentAutoGenerateDeleteSchedule();

  const { data: settingsData } = useContentAutoGenerateGetSettings(businessId);

  // ===== FORM STATE =====
  const [formBasic, setFormBasic] = useState<BasicForm>(initialFormBasic);
  const [formAdvance, setFormAdvance] = useState<GenerateContentAdvanceBase>(initialFormAdvance);
  const [enabledAdvance, setEnabledAdvance] = useState<AdvancedGenerate>(initialEnabledAdvance);
  const [formMask, setFormMask] = useState<string | null>(null);
  const [selectedTemplate, setSelectedTemplate] = useState<Template | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [unsaveModal, setUnsaveModal] = useState<{
    isOpen: boolean;
    item: Template | null;
    isLoading: boolean;
  }>({
    isOpen: false,
    item: null,
    isLoading: false,
  });

  // ===== AI MODELS =====
  const { data: aiModelsRes, isLoading: isLoadingAiModels } = useContentAiModelGetAiModels();
  const [selectedAiModel, setSelectedAiModel] = useState<AiModelRes | null>(null);

  // Set default AI model when models are loaded
  useEffect(() => {
    if (aiModelsRes?.data?.data && aiModelsRes.data.data.length > 0 && !selectedAiModel) {
      const defaultModel = aiModelsRes.data.data[0];
      setSelectedAiModel(defaultModel);
      setFormBasic(prev => ({
        ...prev,
        model: defaultModel.name,
        ratio: (defaultModel.validRatios[0] || prev.ratio || "1:1") as ValidRatio,
        imageSize: defaultModel.imageSizes?.[0] || null,
      }));
    }
  }, [aiModelsRes, selectedAiModel]);

  // Get valid ratios from selected model
  const validRatios = useMemo(() => {
    return selectedAiModel?.validRatios || [];
  }, [selectedAiModel]);

  // ===== PRODUCT KNOWLEDGE =====
  const { data: productKnowledgeRes } = useProductKnowledgeGetStatus(
    businessId,
    formBasic?.productKnowledgeId
  );

  useEffect(() => {
    if (productKnowledgeRes) {
      setEnabledAdvance(productKnowledgeRes.data.data);
    }
  }, [productKnowledgeRes]);

  // ===== TEMPLATES =====
  const { data: productCategoriesData } = useLibraryTemplateGetProductCategory();

  // Published Templates
  const [publishedPagination, setPublishedPagination] = useState<Pagination>(initialPagination);
  const [publishedQuery, setPublishedQuery] = useState<Partial<FilterQuery>>({
    limit: 10,
    page: 1,
    sortBy: "createdAt",
    sort: "desc",
  });
  
  // Fetch all data when category filter is applied, otherwise use normal pagination
  const publishedApiQuery = useMemo(() => {
    if (publishedQuery.productCategory) {
      // Fetch all data for client-side filtering and pagination
      return {
        ...publishedQuery,
        limit: 999, // Fetch all data
        page: 1,
      };
    }
    return publishedQuery;
  }, [publishedQuery]);
  
  const { data: publishedRes, isLoading: isLoadingPublished } = useLibraryTemplateGetPublished(businessId, publishedApiQuery);
  
  useEffect(() => {
    if (publishedRes) {
      setPublishedPagination(publishedRes?.data?.pagination);
    }
  }, [publishedRes]);

  const publishedData: Template[] = (publishedRes?.data.data || []).map((item) => ({
    id: item?.id,
    name: item?.name,
    imageUrl: item?.imageUrl,
    categories: item?.templateImageCategories.map((cat) => cat.name) || [],
    productCategories: item?.templateProductCategories.map((cat) => cat.indonesianName) || [],
    price: 0,
    publisher: item?.publisher || {
      id: "",
      name: "Postmatic",
      image: null,
    },
    type: "published",
    createdAt: item?.createdAt,
    updatedAt: item?.updatedAt,
  }));

  // Client-side filtering by productCategory
  const allFilteredPublishedData = useMemo(() => {
    if (!publishedQuery.productCategory) {
      return publishedData;
    }
    
    const selectedCategory = productCategoriesData?.data?.data?.find(
      (cat) => cat.id === publishedQuery.productCategory
    );
    
    if (!selectedCategory) {
      return publishedData;
    }
    
    return publishedData.filter(template => 
      template.productCategories.includes(selectedCategory.indonesianName)
    );
  }, [publishedData, publishedQuery.productCategory, productCategoriesData]);

  // Apply client-side pagination when category filter is active
  const { paginatedData: filteredPublishedData, pagination: adjustedPublishedPagination } = useMemo(() => {
    // If category filter is applied, do client-side pagination
    if (publishedQuery.productCategory) {
      const limit = publishedQuery.limit || 10;
      const page = publishedQuery.page || 1;
      const total = allFilteredPublishedData.length;
      const totalPages = Math.max(1, Math.ceil(total / limit));
      
      // Slice data for current page
      const start = (page - 1) * limit;
      const end = start + limit;
      const paginatedData = allFilteredPublishedData.slice(start, end);
      
      const pagination: Pagination = {
        limit,
        page,
        total,
        totalPages,
        hasNextPage: page < totalPages,
        hasPrevPage: page > 1,
      };
      
      return { paginatedData, pagination };
    }
    
    // Otherwise use server-side pagination
    return { paginatedData: allFilteredPublishedData, pagination: publishedPagination };
  }, [allFilteredPublishedData, publishedQuery.productCategory, publishedQuery.limit, publishedQuery.page, publishedPagination]);

  // Saved Templates
  const [savedPagination, setSavedPagination] = useState<Pagination>(initialPagination);
  const [savedQuery, setSavedQuery] = useState<Partial<FilterQuery>>({
    limit: 10,
    page: 1,
    sortBy: "createdAt",
    sort: "desc",
  });
  
  // Fetch all data when category filter is applied, otherwise use normal pagination
  const savedApiQuery = useMemo(() => {
    if (savedQuery.productCategory) {
      // Fetch all data for client-side filtering and pagination
      return {
        ...savedQuery,
        limit: 999, // Fetch all data
        page: 1,
      };
    }
    return savedQuery;
  }, [savedQuery]);
  
  const { data: savedRes, isLoading: isLoadingSaved } = useLibraryTemplateGetSaved(businessId, savedApiQuery);
  
  useEffect(() => {
    if (savedRes) {
      setSavedPagination(savedRes?.data?.pagination);
    }
  }, [savedRes]);

  const savedData: Template[] = (savedRes?.data.data || []).map((item) => ({
    id: item?.templateImageContent?.id,
    name: item?.name,
    imageUrl: item?.imageUrl,
    categories: item?.templateImageContent?.templateImageCategories.map((cat) => cat.name) || [],
    productCategories: item?.templateImageContent?.templateProductCategories.map((cat) => cat.indonesianName) || [],
    price: 0,
    publisher: item?.templateImageContent?.publisher || {
      id: "",
      name: "Postmatic",
      image: null,
    },
    type: "saved",
    createdAt: item?.createdAt,
    updatedAt: item?.updatedAt,
  }));

  // Client-side filtering by productCategory for saved templates
  const allFilteredSavedData = useMemo(() => {
    if (!savedQuery.productCategory) {
      return savedData;
    }
    
    const selectedCategory = productCategoriesData?.data?.data?.find(
      (cat) => cat.id === savedQuery.productCategory
    );
    
    if (!selectedCategory) {
      return savedData;
    }
    
    return savedData.filter(template => 
      template.productCategories.includes(selectedCategory.indonesianName)
    );
  }, [savedData, savedQuery.productCategory, productCategoriesData]);

  // Apply client-side pagination when category filter is active
  const { paginatedData: filteredSavedData, pagination: adjustedSavedPagination } = useMemo(() => {
    // If category filter is applied, do client-side pagination
    if (savedQuery.productCategory) {
      const limit = savedQuery.limit || 10;
      const page = savedQuery.page || 1;
      const total = allFilteredSavedData.length;
      const totalPages = Math.max(1, Math.ceil(total / limit));
      
      // Slice data for current page
      const start = (page - 1) * limit;
      const end = start + limit;
      const paginatedData = allFilteredSavedData.slice(start, end);
      
      const pagination: Pagination = {
        limit,
        page,
        total,
        totalPages,
        hasNextPage: page < totalPages,
        hasPrevPage: page > 1,
      };
      
      return { paginatedData, pagination };
    }
    
    // Otherwise use server-side pagination
    return { paginatedData: allFilteredSavedData, pagination: savedPagination };
  }, [allFilteredSavedData, savedQuery.productCategory, savedQuery.limit, savedQuery.page, savedPagination]);

  // Product Knowledges
  const [productPagination, setProductPagination] = useState<Pagination>(initialPagination);
  const [productQuery, setProductQuery] = useState<Partial<FilterQuery>>({
    limit: 10,
    page: 1,
    sortBy: "name",
    sort: "asc",
  });
  const { data: productRes } = useProductKnowledgeGetAll(businessId, productQuery);
  
  useEffect(() => {
    if (productRes) {
      setProductPagination(productRes?.data?.pagination);
      setProductQuery(prev => ({
        ...prev,
        page: productRes?.data?.pagination?.page,
      }));
    }
  }, [productRes]);

  const products = useMemo(() => productRes?.data?.data || [], [productRes?.data?.data]);

  // ===== HANDLERS =====
  const onSelectProduct = useCallback((item: ProductKnowledgeRes | null) => {
    if (item) {
      setFormBasic({
        ...formBasic,
        productKnowledgeId: item.id,
        productName: item.name,
        productImage: item.images?.[0] || "",
        customCategory: "",
        customDesignStyle: "",
      });
    }
  }, [formBasic]);

  const onSelectReferenceImage = useCallback((
    imageUrl: string,
    imageName: string | null,
    template?: Template
  ) => {
    setFormBasic({
      ...formBasic,
      referenceImage: imageUrl,
      referenceImageName: imageName,
      referenceImagePublisher: template?.publisher?.name || null,
    });

    // Set selected template for visual feedback
    if (template) {
      setSelectedTemplate(template);
    }

    // Add automatic scrolling to form section
    setTimeout(() => {
      const formSectionElement =
        document.getElementById("auto-generate-form-section");
      console.log("Auto-scroll: formSectionElement found:", !!formSectionElement);
      if (formSectionElement) {
        console.log("Auto-scroll: scrolling to form section");
        formSectionElement.scrollIntoView({ behavior: "smooth" });
      }
    }, 100);
  }, [formBasic]);

  const onSelectAiModel = useCallback((model: AiModelRes) => {
    setSelectedAiModel(model);
    setFormBasic(prev => {
      // Check if current ratio is valid for the new model
      const currentRatio = prev.ratio;
      const isValidRatio = model.validRatios.includes(currentRatio);
      
      return {
        ...prev,
        model: model.name,
        // Only change ratio if current ratio is not valid for new model
        ratio: isValidRatio ? currentRatio : (model.validRatios[0] || "1:1") as ValidRatio,
        imageSize: model.imageSizes?.[0] || null,
      };
    });
  }, []);

  const onResetAdvance = useCallback(() => {
    setFormAdvance(initialFormAdvance);
  }, []);

  // Save/Unsave handlers
  const mSave = useLibraryTemplateSave();
  const mUnsave = useLibraryTemplateDeleteSaved();
  
  const onSaveUnsave = useCallback(async (item: Template) => {
    try {
      switch (item.type) {
        case "published":
          const resPub = await mSave.mutateAsync({
            businessId,
            formData: {
              templateImageContentId: item.id,
            },
          });
          showToast("success", resPub.data.responseMessage);
          break;
        case "saved":
          // Show confirmation modal for saved items
          setUnsaveModal({
            isOpen: true,
            item: item,
            isLoading: false,
          });
          break;
      }
    } catch (error) {
      showToast("error", error);
    }
  }, [businessId, mSave]);

  const onConfirmUnsave = useCallback(async () => {
    if (!unsaveModal.item) return;

    setUnsaveModal((prev) => ({ ...prev, isLoading: true }));
    try {
      const resUnpub = await mUnsave.mutateAsync({
        businessId,
        templateId: unsaveModal.item.id,
      });
      showToast("success", resUnpub.data.responseMessage);
      setUnsaveModal({
        isOpen: false,
        item: null,
        isLoading: false,
      });
    } catch (error) {
      showToast("error", error);
      setUnsaveModal((prev) => ({ ...prev, isLoading: false }));
    }
  }, [businessId, mUnsave, unsaveModal.item]);

  const onCloseUnsaveModal = useCallback(() => {
    if (!unsaveModal.isLoading) {
      setUnsaveModal({
        isOpen: false,
        item: null,
        isLoading: false,
      });
    }
  }, [unsaveModal.isLoading]);

  // ===== FORM OBJECT =====
  const form = useMemo(() => ({
    basic: formBasic,
    advance: formAdvance,
    setBasic: setFormBasic,
    setAdvance: setFormAdvance,
    enabledAdvance: enabledAdvance,
    setEnabledAdvance: setEnabledAdvance,
    mask: formMask,
    setMask: setFormMask,
  }), [formBasic, formAdvance, enabledAdvance, formMask]);

  // ===== TEMPLATE OBJECTS =====
  const publishedTemplates = useMemo(() => ({
    contents: filteredPublishedData,
    pagination: adjustedPublishedPagination,
    filterQuery: publishedQuery,
    setFilterQuery: setPublishedQuery,
    isLoading: isLoadingPublished,
  }), [filteredPublishedData, adjustedPublishedPagination, publishedQuery, isLoadingPublished]);

  const savedTemplates = useMemo(() => ({
    contents: filteredSavedData,
    pagination: adjustedSavedPagination,
    filterQuery: savedQuery,
    setFilterQuery: setSavedQuery,
    isLoading: isLoadingSaved,
  }), [filteredSavedData, adjustedSavedPagination, savedQuery, isLoadingSaved]);

  const productKnowledges = useMemo(() => ({
    contents: products,
    pagination: productPagination,
    filterQuery: productQuery,
    setFilterQuery: setProductQuery,
  }), [products, productPagination, productQuery]);

  const aiModels = useMemo(() => ({
    models: aiModelsRes?.data?.data || [],
    selectedModel: selectedAiModel,
    validRatios,
    isLoading: isLoadingAiModels,
  }), [aiModelsRes?.data?.data, selectedAiModel, validRatios, isLoadingAiModels]);

  // --- INIT AWAL (kosong aman) ---
  const baseRef = useRef<{ enabled: boolean; schedules: AutoGenerateSettings }>({
    enabled: false,
    schedules: {
      preference: { isActive: false },
      schedules: Array.from({ length: 7 }, (_, i) => ({ day: i, schedules: [] })),
    },
  });

  const draftRef = useRef<{ enabled: boolean; schedules: AutoGenerateSettings }>(
    structuredClone(baseRef.current)
  );

  const [, setVersion] = useState(0);
  const bump = () => setVersion((v) => v + 1);

  const [loading, setLoading] = useState(false);
  const inflightRef = useRef(false);

  // === SYNC: ketika data API datang atau businessId berubah ===
  useEffect(() => {
    const server = settingsData?.data?.data as AutoGenerateSettings | undefined;
    if (!server) return; // belum ada data

    // commit dari server -> base & draft
    baseRef.current = {
      enabled: !!server.preference.isActive,
      schedules: server,
    };
    draftRef.current = structuredClone(baseRef.current);

    // trigger re-render agar UI update
    bump();
  }, [settingsData?.data?.data]);

  // (opsional) reset ketika businessId berubah total
  useEffect(() => {
    // reset ke kosong saat ganti bisnis, sampai data baru datang
    baseRef.current = {
      enabled: false,
      schedules: {
        preference: { isActive: false },
        schedules: Array.from({ length: 7 }, (_, i) => ({ day: i, schedules: [] })),
      },
    };
    draftRef.current = structuredClone(baseRef.current);
    bump();
  }, [businessId]);

  // ===== Helpers =====
  // Calculate isChanged dynamically
  const isChanged = stableSig(draftRef.current) !== stableSig(baseRef.current);
  
  // Debug logging for isChanged calculation
  console.log('isChanged calculation:', {
    draftEnabled: draftRef.current.enabled,
    baseEnabled: baseRef.current.enabled,
    draftSig: stableSig(draftRef.current),
    baseSig: stableSig(baseRef.current),
    isChanged
  });

  // ===== Mutators =====
  const setGlobalEnabled = useCallback((next: boolean) => {
    console.log('setGlobalEnabled called with:', next);
    console.log('Current draftRef.enabled:', draftRef.current.enabled);
    console.log('Current baseRef.enabled:', baseRef.current.enabled);
    
    draftRef.current = { 
      ...draftRef.current, 
      enabled: next,
      schedules: {
        ...draftRef.current.schedules,
        preference: { isActive: next }
      }
    };
    
    console.log('After update - draftRef.enabled:', draftRef.current.enabled);
    bump();
  }, []);

  const toggleDay = useCallback((day: number) => {
    const copy = structuredClone(draftRef.current);
    const daySchedule = copy.schedules.schedules.find(s => s.day === day);
    if (daySchedule) {
      // Toggle all schedules in this day
      daySchedule.schedules.forEach(schedule => {
        schedule.isActive = !schedule.isActive;
      });
    }
    draftRef.current = copy;
    bump();
  }, []);

  const addSchedule = useCallback(
    (day: number, scheduleData: CreateAutoGenerateScheduleRequest) => {
      const copy = structuredClone(draftRef.current);
      const daySchedule = copy.schedules.schedules.find(s => s.day === day);
      if (daySchedule) {
        const newSchedule: AutoGenerateSchedule = {
          id: `temp-${Date.now()}`, // temporary ID
          isActive: scheduleData.isActive,
          day,
          time: scheduleData.time,
          platforms: scheduleData.platforms,
          model: scheduleData.model,
          designStyle: scheduleData.designStyle,
          ratio: scheduleData.ratio,
          referenceImages: scheduleData.referenceImages,
          category: scheduleData.category,
          additionalPrompt: scheduleData.additionalPrompt || null,
          productKnowledgeId: scheduleData.productKnowledgeId,
          rootBusinessId: businessId,
          advBusinessName: scheduleData.advBusinessName,
          advBusinessCategory: scheduleData.advBusinessCategory,
          advBusinessDescription: scheduleData.advBusinessDescription,
          advBusinessLocation: scheduleData.advBusinessLocation,
          advBusinessLogo: scheduleData.advBusinessLogo,
          advBusinessUniqueSellingPoint: scheduleData.advBusinessUniqueSellingPoint,
          advBusinessWebsite: scheduleData.advBusinessWebsite,
          advBusinessVisionMission: scheduleData.advBusinessVisionMission,
          advBusinessColorTone: scheduleData.advBusinessColorTone,
          advProductName: scheduleData.advProductName,
          advProductCategory: scheduleData.advProductCategory,
          advProductDescription: scheduleData.advProductDescription,
          advProductPrice: scheduleData.advProductPrice,
          advRoleHashtags: scheduleData.advRoleHashtags,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        };
        daySchedule.schedules.push(newSchedule);
      }
      draftRef.current = copy;
      bump();
    },
    [businessId]
  );

  const updateSchedule = useCallback(
    (scheduleId: string, scheduleData: UpdateAutoGenerateScheduleRequest) => {
      const copy = structuredClone(draftRef.current);
      for (const daySchedule of copy.schedules.schedules) {
        const schedule = daySchedule.schedules.find(s => s.id === scheduleId);
        if (schedule) {
          Object.assign(schedule, {
            ...scheduleData,
            updatedAt: new Date().toISOString(),
          });
          break;
        }
      }
      draftRef.current = copy;
      bump();
    },
    []
  );

  const removeSchedule = useCallback((scheduleId: string) => {
    const copy = structuredClone(draftRef.current);
    for (const daySchedule of copy.schedules.schedules) {
      daySchedule.schedules = daySchedule.schedules.filter(s => s.id !== scheduleId);
    }
    draftRef.current = copy;
    bump();
  }, []);

  // Direct delete function that immediately calls API
  const deleteScheduleDirectly = useCallback(async (scheduleId: string) => {
    try {
      // Remove from server first
      await mDeleteSchedule.mutateAsync({
        businessId,
        scheduleId,
      });
      
      // Then remove from local state
      const copy = structuredClone(draftRef.current);
      for (const daySchedule of copy.schedules.schedules) {
        daySchedule.schedules = daySchedule.schedules.filter(s => s.id !== scheduleId);
      }
      draftRef.current = copy;
      
      // Also update baseRef to keep them in sync
      const baseCopy = structuredClone(baseRef.current);
      for (const daySchedule of baseCopy.schedules.schedules) {
        daySchedule.schedules = daySchedule.schedules.filter(s => s.id !== scheduleId);
      }
      baseRef.current = baseCopy;
      
      bump();
      showToast("success", t("toast.general.saved"));
    } catch (error) {
      showToast("error", error);
    }
  }, [businessId, mDeleteSchedule, t]);

  const getSchedulesByDay = useCallback((day: number) => {
    const daySchedule = draftRef.current.schedules.schedules.find(s => s.day === day);
    return daySchedule?.schedules || [];
  }, []);

  // ===== Upsert =====
  const onUpsert = useCallback(async () => {
    console.log('onUpsert called - isChanged:', isChanged);
    console.log('draftRef.current.enabled:', draftRef.current.enabled);
    console.log('baseRef.current.enabled:', baseRef.current.enabled);
    
    // Check if there's a change in enabled status specifically
    const enabledChanged = draftRef.current.enabled !== baseRef.current.enabled;
    console.log('enabledChanged:', enabledChanged);
    
    if (!isChanged && !enabledChanged) {
      console.log('No changes detected, showing toast');
      showToast("info", t("toast.general.noChangesToSave"));
      return;
    }
    if (inflightRef.current || loading) return;
    inflightRef.current = true;
    setLoading(true);

    try {
      // Update preference first
      if (enabledChanged) {
        console.log('Sending PATCH request for preference:', {
          businessId,
          isActive: draftRef.current.enabled,
          from: baseRef.current.enabled,
          to: draftRef.current.enabled
        });
        await mUpdatePreference.mutateAsync({
          businessId,
          isActive: draftRef.current.enabled,
        });
        console.log('PATCH request completed successfully');
      }

      // Handle schedule changes
      const baseSchedules = baseRef.current.schedules.schedules;
      const draftSchedules = draftRef.current.schedules.schedules;

      for (let day = 0; day < 7; day++) {
        const baseDaySchedules = baseSchedules.find(s => s.day === day)?.schedules || [];
        const draftDaySchedules = draftSchedules.find(s => s.day === day)?.schedules || [];

        // Find new schedules (temp IDs)
        const newSchedules = draftDaySchedules.filter(s => s.id.startsWith('temp-'));
        for (const schedule of newSchedules) {
          await mCreateSchedule.mutateAsync({
            businessId,
            formData: {
              day: schedule.day,
              time: schedule.time,
              platforms: schedule.platforms,
              model: schedule.model,
              designStyle: schedule.designStyle,
              ratio: schedule.ratio,
              referenceImages: schedule.referenceImages,
              category: schedule.category,
              additionalPrompt: schedule.additionalPrompt || undefined,
              productKnowledgeId: schedule.productKnowledgeId,
              isActive: schedule.isActive,
              advBusinessName: schedule.advBusinessName,
              advBusinessCategory: schedule.advBusinessCategory,
              advBusinessDescription: schedule.advBusinessDescription,
              advBusinessLocation: schedule.advBusinessLocation,
              advBusinessLogo: schedule.advBusinessLogo,
              advBusinessUniqueSellingPoint: schedule.advBusinessUniqueSellingPoint,
              advBusinessWebsite: schedule.advBusinessWebsite,
              advBusinessVisionMission: schedule.advBusinessVisionMission,
              advBusinessColorTone: schedule.advBusinessColorTone,
              advProductName: schedule.advProductName,
              advProductCategory: schedule.advProductCategory,
              advProductDescription: schedule.advProductDescription,
              advProductPrice: schedule.advProductPrice,
              advRoleHashtags: schedule.advRoleHashtags,
            },
          });
        }

        // Find updated schedules
        for (const draftSchedule of draftDaySchedules) {
          if (draftSchedule.id.startsWith('temp-')) continue; // Skip new schedules
          
          const baseSchedule = baseDaySchedules.find(s => s.id === draftSchedule.id);
          if (baseSchedule && stableSig(baseSchedule) !== stableSig(draftSchedule)) {
            await mUpdateSchedule.mutateAsync({
              businessId,
              scheduleId: draftSchedule.id,
              formData: {
                day: draftSchedule.day,
                time: draftSchedule.time,
                platforms: draftSchedule.platforms,
                model: draftSchedule.model,
                designStyle: draftSchedule.designStyle,
                ratio: draftSchedule.ratio,
                referenceImages: draftSchedule.referenceImages,
                category: draftSchedule.category,
                additionalPrompt: draftSchedule.additionalPrompt || undefined,
                productKnowledgeId: draftSchedule.productKnowledgeId,
                isActive: draftSchedule.isActive,
                advBusinessName: draftSchedule.advBusinessName,
                advBusinessCategory: draftSchedule.advBusinessCategory,
                advBusinessDescription: draftSchedule.advBusinessDescription,
                advBusinessLocation: draftSchedule.advBusinessLocation,
                advBusinessLogo: draftSchedule.advBusinessLogo,
                advBusinessUniqueSellingPoint: draftSchedule.advBusinessUniqueSellingPoint,
                advBusinessWebsite: draftSchedule.advBusinessWebsite,
                advBusinessVisionMission: draftSchedule.advBusinessVisionMission,
                advBusinessColorTone: draftSchedule.advBusinessColorTone,
                advProductName: draftSchedule.advProductName,
                advProductCategory: draftSchedule.advProductCategory,
                advProductDescription: draftSchedule.advProductDescription,
                advProductPrice: draftSchedule.advProductPrice,
                advRoleHashtags: draftSchedule.advRoleHashtags,
              },
            });
          }
        }

        // Find deleted schedules
        for (const baseSchedule of baseDaySchedules) {
          const stillExists = draftDaySchedules.some(s => s.id === baseSchedule.id);
          if (!stillExists) {
            await mDeleteSchedule.mutateAsync({
              businessId,
              scheduleId: baseSchedule.id,
            });
          }
        }
      }

      baseRef.current = structuredClone(draftRef.current);
      showToast("success", t("toast.general.saved"));
      bump(); // agar isChanged -> false
    } catch (e) {
      showToast("error", e);
    } finally {
      inflightRef.current = false;
      setLoading(false);
    }
  }, [businessId, isChanged, loading, mUpdatePreference, mCreateSchedule, mUpdateSchedule, mDeleteSchedule, t]);

  // ===== Unsaved changes guard =====
  const confirmLeave = useCallback(() => {
    if (!isChanged) return true;
    return window.confirm(
      "Perubahan belum disimpan. Tinggalkan halaman tanpa menyimpan?"
    );
  }, [isChanged]);

  const guardedNavigate = useCallback(
    (href: string, navigate: (href: string) => void) => {
      const ok = confirmLeave();
      if (ok) navigate(href);
    },
    [confirmLeave]
  );

  useEffect(() => {
    if (!isChanged) return;
    const handler = (e: BeforeUnloadEvent) => {
      e.preventDefault();
      e.returnValue = "";
      return "";
    };
    window.addEventListener("beforeunload", handler);
    return () => window.removeEventListener("beforeunload", handler);
  }, [isChanged]);

  useEffect(() => {
    if (!isChanged) return;
    const onDocumentClick = (e: MouseEvent) => {
      if (
        e.defaultPrevented ||
        e.metaKey ||
        e.ctrlKey ||
        e.shiftKey ||
        e.altKey
      )
        return;
      const target = e.target as HTMLElement | null;
      const a = target?.closest("a") as HTMLAnchorElement | null;
      if (!a) return;
      const url = new URL(a.href, window.location.href);
      const isSameOrigin = url.origin === window.location.origin;
      const isSelf = !a.target || a.target === "_self";
      if (isSameOrigin && isSelf) {
        const ok = window.confirm(
          "Perubahan belum disimpan. Tinggalkan halaman tanpa menyimpan?"
        );
        if (!ok) {
          e.preventDefault();
          e.stopPropagation();
        }
      }
    };
    const onPopState = () => {
      const ok = window.confirm(
        "Perubahan belum disimpan. Tinggalkan halaman tanpa menyimpan?"
      );
      if (!ok) history.pushState(null, "", window.location.href);
    };
    document.addEventListener("click", onDocumentClick, true);
    window.addEventListener("popstate", onPopState);
    return () => {
      document.removeEventListener("click", onDocumentClick, true);
      window.removeEventListener("popstate", onPopState);
    };
  }, [isChanged]);

  // ===== Value =====
  const value = useMemo<Ctx>(
    () => ({
      // Auto Generate Settings
      enabled: draftRef.current.enabled,
      schedules: draftRef.current.schedules,
      isValueChanged: isChanged,
      loading,
      onUpsert,
      confirmLeave,
      guardedNavigate,
      setGlobalEnabled,
      toggleDay,
      addSchedule,
      updateSchedule,
      removeSchedule,
      deleteScheduleDirectly,
      getSchedulesByDay,

      // Form Management
      form,
      selectedTemplate,
      setSelectedTemplate,

      // Template Management
      publishedTemplates,
      savedTemplates,

      // Product Knowledge
      productKnowledges,

      // AI Models
      aiModels,

      // Loading state
      isLoading,
      setIsLoading,

      // Unsave modal
      unsaveModal,
      setUnsaveModal,

      // Handlers
      onSaveUnsave,
      onConfirmUnsave,
      onCloseUnsaveModal,
      onSelectProduct,
      onSelectReferenceImage,
      onSelectAiModel,
      onResetAdvance,
    }),
    [
      isChanged,
      loading,
      onUpsert,
      confirmLeave,
      guardedNavigate,
      setGlobalEnabled,
      toggleDay,
      addSchedule,
      updateSchedule,
      removeSchedule,
      deleteScheduleDirectly,
      getSchedulesByDay,
      form,
      selectedTemplate,
      publishedTemplates,
      savedTemplates,
      productKnowledges,
      aiModels,
      isLoading,
      unsaveModal,
      onSaveUnsave,
      onConfirmUnsave,
      onCloseUnsaveModal,
      onSelectProduct,
      onSelectReferenceImage,
      onSelectAiModel,
      onResetAdvance,
    ]
  );

  return (
    <AutoGenerateContext.Provider value={value}>
      {children}
    </AutoGenerateContext.Provider>
  );
}
