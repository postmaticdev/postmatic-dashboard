"use client";

import React, {
  createContext,
  useCallback,
  useContext,
  useMemo,
  useRef,
  useState,
  useEffect,
} from "react";
import { showToast } from "@/helper/show-toast";
import { useTranslations } from "next-intl";
import { PlatformEnum } from "@/models/api/knowledge/platform.type";
import {
  useContentAutoGenerateGetSettings,
  useContentAutoGenerateUpdatePreference,
  useContentAutoGenerateCreateSchedule,
  useContentAutoGenerateUpdateSchedule,
  useContentAutoGenerateDeleteSchedule,
} from "@/services/content/content.api";
import {
  AutoGenerateSettings,
  AutoGenerateSchedule,
  CreateAutoGenerateScheduleRequest,
  UpdateAutoGenerateScheduleRequest,
} from "@/models/api/content/auto-generate";
import { useParams } from "next/navigation";

type Ctx = {
  enabled: boolean;
  schedules: AutoGenerateSettings;
  isValueChanged: boolean;
  loading: boolean;
  onUpsert: () => Promise<void>;
  confirmLeave: () => boolean;
  guardedNavigate: (href: string, navigate: (href: string) => void) => void;
  setGlobalEnabled: (next: boolean) => void;
  toggleDay: (day: number) => void;
  addSchedule: (day: number, schedule: CreateAutoGenerateScheduleRequest) => void;
  updateSchedule: (scheduleId: string, schedule: UpdateAutoGenerateScheduleRequest) => void;
  removeSchedule: (scheduleId: string) => void;
  getSchedulesByDay: (day: number) => AutoGenerateSchedule[];
};

const AutoGenerateContext = createContext<Ctx | null>(null);

export function useAutoGenerate() {
  const ctx = useContext(AutoGenerateContext);
  if (!ctx)
    throw new Error(
      "useAutoGenerate must be used within AutoGenerateProvider"
    );
  return ctx;
}

function uniq<T>(arr: T[]) {
  return Array.from(new Set(arr));
}

function stableSig(obj: unknown) {
  return JSON.stringify(obj);
}

export function AutoGenerateProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const { businessId } = useParams() as { businessId: string };
  const t = useTranslations();
  const mUpdatePreference = useContentAutoGenerateUpdatePreference();
  const mCreateSchedule = useContentAutoGenerateCreateSchedule();
  const mUpdateSchedule = useContentAutoGenerateUpdateSchedule();
  const mDeleteSchedule = useContentAutoGenerateDeleteSchedule();

  const { data: settingsData } = useContentAutoGenerateGetSettings(businessId);

  // --- INIT AWAL (kosong aman) ---
  const baseRef = useRef<{ enabled: boolean; schedules: AutoGenerateSettings }>({
    enabled: false,
    schedules: {
      preference: { isActive: false },
      schedules: Array.from({ length: 7 }, (_, i) => ({ day: i, schedules: [] })),
    },
  });

  const draftRef = useRef<{ enabled: boolean; schedules: AutoGenerateSettings }>(
    structuredClone(baseRef.current)
  );

  const [version, setVersion] = useState(0);
  const bump = () => setVersion((v) => v + 1);

  const [loading, setLoading] = useState(false);
  const inflightRef = useRef(false);

  // === SYNC: ketika data API datang atau businessId berubah ===
  useEffect(() => {
    const server = settingsData?.data?.data as AutoGenerateSettings | undefined;
    if (!server) return; // belum ada data

    // commit dari server -> base & draft
    baseRef.current = {
      enabled: !!server.preference.isActive,
      schedules: server,
    };
    draftRef.current = structuredClone(baseRef.current);

    // trigger re-render agar UI update
    bump();
  }, [settingsData?.data?.data]);

  // (opsional) reset ketika businessId berubah total
  useEffect(() => {
    // reset ke kosong saat ganti bisnis, sampai data baru datang
    baseRef.current = {
      enabled: false,
      schedules: {
        preference: { isActive: false },
        schedules: Array.from({ length: 7 }, (_, i) => ({ day: i, schedules: [] })),
      },
    };
    draftRef.current = structuredClone(baseRef.current);
    bump();
  }, [businessId]);

  // ===== Helpers =====
  const isChanged = useMemo(
    () => stableSig(draftRef.current) !== stableSig(baseRef.current),
    [version]
  );

  // ===== Mutators =====
  const setGlobalEnabled = useCallback((next: boolean) => {
    draftRef.current = { 
      ...draftRef.current, 
      enabled: next,
      schedules: {
        ...draftRef.current.schedules,
        preference: { isActive: next }
      }
    };
    bump();
  }, []);

  const toggleDay = useCallback((day: number) => {
    const copy = structuredClone(draftRef.current);
    const daySchedule = copy.schedules.schedules.find(s => s.day === day);
    if (daySchedule) {
      // Toggle all schedules in this day
      daySchedule.schedules.forEach(schedule => {
        schedule.isActive = !schedule.isActive;
      });
    }
    draftRef.current = copy;
    bump();
  }, []);

  const addSchedule = useCallback(
    (day: number, scheduleData: CreateAutoGenerateScheduleRequest) => {
      const copy = structuredClone(draftRef.current);
      const daySchedule = copy.schedules.schedules.find(s => s.day === day);
      if (daySchedule) {
        const newSchedule: AutoGenerateSchedule = {
          id: `temp-${Date.now()}`, // temporary ID
          isActive: scheduleData.isActive,
          day,
          time: scheduleData.time,
          platforms: scheduleData.platforms,
          model: scheduleData.model,
          designStyle: scheduleData.designStyle,
          ratio: scheduleData.ratio,
          referenceImages: scheduleData.referenceImages,
          category: scheduleData.category,
          additionalPrompt: scheduleData.additionalPrompt || null,
          productKnowledgeId: scheduleData.productKnowledgeId,
          rootBusinessId: businessId,
          advBusinessName: scheduleData.advBusinessName,
          advBusinessCategory: scheduleData.advBusinessCategory,
          advBusinessDescription: scheduleData.advBusinessDescription,
          advBusinessLocation: scheduleData.advBusinessLocation,
          advBusinessLogo: scheduleData.advBusinessLogo,
          advBusinessUniqueSellingPoint: scheduleData.advBusinessUniqueSellingPoint,
          advBusinessWebsite: scheduleData.advBusinessWebsite,
          advBusinessVisionMission: scheduleData.advBusinessVisionMission,
          advBusinessColorTone: scheduleData.advBusinessColorTone,
          advProductName: scheduleData.advProductName,
          advProductCategory: scheduleData.advProductCategory,
          advProductDescription: scheduleData.advProductDescription,
          advProductPrice: scheduleData.advProductPrice,
          advRoleHashtags: scheduleData.advRoleHashtags,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        };
        daySchedule.schedules.push(newSchedule);
      }
      draftRef.current = copy;
      bump();
    },
    [businessId]
  );

  const updateSchedule = useCallback(
    (scheduleId: string, scheduleData: UpdateAutoGenerateScheduleRequest) => {
      const copy = structuredClone(draftRef.current);
      for (const daySchedule of copy.schedules.schedules) {
        const schedule = daySchedule.schedules.find(s => s.id === scheduleId);
        if (schedule) {
          Object.assign(schedule, {
            ...scheduleData,
            updatedAt: new Date().toISOString(),
          });
          break;
        }
      }
      draftRef.current = copy;
      bump();
    },
    []
  );

  const removeSchedule = useCallback((scheduleId: string) => {
    const copy = structuredClone(draftRef.current);
    for (const daySchedule of copy.schedules.schedules) {
      daySchedule.schedules = daySchedule.schedules.filter(s => s.id !== scheduleId);
    }
    draftRef.current = copy;
    bump();
  }, []);

  const getSchedulesByDay = useCallback((day: number) => {
    const daySchedule = draftRef.current.schedules.schedules.find(s => s.day === day);
    return daySchedule?.schedules || [];
  }, []);

  // ===== Upsert =====
  const onUpsert = useCallback(async () => {
    if (!isChanged) {
      showToast("info", t("toast.general.noChangesToSave"));
      return;
    }
    if (inflightRef.current || loading) return;
    inflightRef.current = true;
    setLoading(true);

    try {
      // Update preference first
      if (draftRef.current.enabled !== baseRef.current.enabled) {
        await mUpdatePreference.mutateAsync({
          businessId,
          isActive: draftRef.current.enabled,
        });
      }

      // Handle schedule changes
      const baseSchedules = baseRef.current.schedules.schedules;
      const draftSchedules = draftRef.current.schedules.schedules;

      for (let day = 0; day < 7; day++) {
        const baseDaySchedules = baseSchedules.find(s => s.day === day)?.schedules || [];
        const draftDaySchedules = draftSchedules.find(s => s.day === day)?.schedules || [];

        // Find new schedules (temp IDs)
        const newSchedules = draftDaySchedules.filter(s => s.id.startsWith('temp-'));
        for (const schedule of newSchedules) {
          await mCreateSchedule.mutateAsync({
            businessId,
            formData: {
              day: schedule.day,
              time: schedule.time,
              platforms: schedule.platforms,
              model: schedule.model,
              designStyle: schedule.designStyle,
              ratio: schedule.ratio,
              referenceImages: schedule.referenceImages,
              category: schedule.category,
              additionalPrompt: schedule.additionalPrompt || undefined,
              productKnowledgeId: schedule.productKnowledgeId,
              isActive: schedule.isActive,
              advBusinessName: schedule.advBusinessName,
              advBusinessCategory: schedule.advBusinessCategory,
              advBusinessDescription: schedule.advBusinessDescription,
              advBusinessLocation: schedule.advBusinessLocation,
              advBusinessLogo: schedule.advBusinessLogo,
              advBusinessUniqueSellingPoint: schedule.advBusinessUniqueSellingPoint,
              advBusinessWebsite: schedule.advBusinessWebsite,
              advBusinessVisionMission: schedule.advBusinessVisionMission,
              advBusinessColorTone: schedule.advBusinessColorTone,
              advProductName: schedule.advProductName,
              advProductCategory: schedule.advProductCategory,
              advProductDescription: schedule.advProductDescription,
              advProductPrice: schedule.advProductPrice,
              advRoleHashtags: schedule.advRoleHashtags,
            },
          });
        }

        // Find updated schedules
        for (const draftSchedule of draftDaySchedules) {
          if (draftSchedule.id.startsWith('temp-')) continue; // Skip new schedules
          
          const baseSchedule = baseDaySchedules.find(s => s.id === draftSchedule.id);
          if (baseSchedule && stableSig(baseSchedule) !== stableSig(draftSchedule)) {
            await mUpdateSchedule.mutateAsync({
              businessId,
              scheduleId: draftSchedule.id,
              formData: {
                day: draftSchedule.day,
                time: draftSchedule.time,
                platforms: draftSchedule.platforms,
                model: draftSchedule.model,
                designStyle: draftSchedule.designStyle,
                ratio: draftSchedule.ratio,
                referenceImages: draftSchedule.referenceImages,
                category: draftSchedule.category,
                additionalPrompt: draftSchedule.additionalPrompt || undefined,
                productKnowledgeId: draftSchedule.productKnowledgeId,
                isActive: draftSchedule.isActive,
                advBusinessName: draftSchedule.advBusinessName,
                advBusinessCategory: draftSchedule.advBusinessCategory,
                advBusinessDescription: draftSchedule.advBusinessDescription,
                advBusinessLocation: draftSchedule.advBusinessLocation,
                advBusinessLogo: draftSchedule.advBusinessLogo,
                advBusinessUniqueSellingPoint: draftSchedule.advBusinessUniqueSellingPoint,
                advBusinessWebsite: draftSchedule.advBusinessWebsite,
                advBusinessVisionMission: draftSchedule.advBusinessVisionMission,
                advBusinessColorTone: draftSchedule.advBusinessColorTone,
                advProductName: draftSchedule.advProductName,
                advProductCategory: draftSchedule.advProductCategory,
                advProductDescription: draftSchedule.advProductDescription,
                advProductPrice: draftSchedule.advProductPrice,
                advRoleHashtags: draftSchedule.advRoleHashtags,
              },
            });
          }
        }

        // Find deleted schedules
        for (const baseSchedule of baseDaySchedules) {
          const stillExists = draftDaySchedules.some(s => s.id === baseSchedule.id);
          if (!stillExists) {
            await mDeleteSchedule.mutateAsync({
              businessId,
              scheduleId: baseSchedule.id,
            });
          }
        }
      }

      baseRef.current = structuredClone(draftRef.current);
      showToast("success", t("toast.general.saved"));
      bump(); // agar isChanged -> false
    } catch (e) {
      showToast("error", e);
    } finally {
      inflightRef.current = false;
      setLoading(false);
    }
  }, [businessId, isChanged, loading, mUpdatePreference, mCreateSchedule, mUpdateSchedule, mDeleteSchedule, t]);

  // ===== Unsaved changes guard =====
  const confirmLeave = useCallback(() => {
    if (!isChanged) return true;
    return window.confirm(
      "Perubahan belum disimpan. Tinggalkan halaman tanpa menyimpan?"
    );
  }, [isChanged]);

  const guardedNavigate = useCallback(
    (href: string, navigate: (href: string) => void) => {
      const ok = confirmLeave();
      if (ok) navigate(href);
    },
    [confirmLeave]
  );

  useEffect(() => {
    if (!isChanged) return;
    const handler = (e: BeforeUnloadEvent) => {
      e.preventDefault();
      e.returnValue = "";
      return "";
    };
    window.addEventListener("beforeunload", handler);
    return () => window.removeEventListener("beforeunload", handler);
  }, [isChanged]);

  useEffect(() => {
    if (!isChanged) return;
    const onDocumentClick = (e: MouseEvent) => {
      if (
        e.defaultPrevented ||
        e.metaKey ||
        e.ctrlKey ||
        e.shiftKey ||
        e.altKey
      )
        return;
      const target = e.target as HTMLElement | null;
      const a = target?.closest("a") as HTMLAnchorElement | null;
      if (!a) return;
      const url = new URL(a.href, window.location.href);
      const isSameOrigin = url.origin === window.location.origin;
      const isSelf = !a.target || a.target === "_self";
      if (isSameOrigin && isSelf) {
        const ok = window.confirm(
          "Perubahan belum disimpan. Tinggalkan halaman tanpa menyimpan?"
        );
        if (!ok) {
          e.preventDefault();
          e.stopPropagation();
        }
      }
    };
    const onPopState = () => {
      const ok = window.confirm(
        "Perubahan belum disimpan. Tinggalkan halaman tanpa menyimpan?"
      );
      if (!ok) history.pushState(null, "", window.location.href);
    };
    document.addEventListener("click", onDocumentClick, true);
    window.addEventListener("popstate", onPopState);
    return () => {
      document.removeEventListener("click", onDocumentClick, true);
      window.removeEventListener("popstate", onPopState);
    };
  }, [isChanged]);

  // ===== Value =====
  const value = useMemo<Ctx>(
    () => ({
      enabled: draftRef.current.enabled,
      schedules: draftRef.current.schedules,
      isValueChanged: isChanged,
      loading,
      onUpsert,
      confirmLeave,
      guardedNavigate,
      setGlobalEnabled,
      toggleDay,
      addSchedule,
      updateSchedule,
      removeSchedule,
      getSchedulesByDay,
    }),
    [
      version,
      isChanged,
      loading,
      onUpsert,
      confirmLeave,
      guardedNavigate,
      setGlobalEnabled,
      toggleDay,
      addSchedule,
      updateSchedule,
      removeSchedule,
      getSchedulesByDay,
    ]
  );

  return (
    <AutoGenerateContext.Provider value={value}>
      {children}
    </AutoGenerateContext.Provider>
  );
}
